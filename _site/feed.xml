<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Leaving the Pipette for a Keyboard.</description>
    <link>http://adomingues.github.io/</link>
    <atom:link href="http://adomingues.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 01 Aug 2016 17:09:37 +0200</pubDate>
    <lastBuildDate>Mon, 01 Aug 2016 17:09:37 +0200</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Sublime Text 3 set-up</title>
        <description>&lt;h2 id=&quot;preamble&quot;&gt;Preamble&lt;/h2&gt;

&lt;p&gt;I am a big fan of Sublime Text! It is a lightweight text editor, inexpensive license, and with contributions by hundreds of users, highly extensible and customizable. From a practical perspective, I prefer to use it instead of IDEs, such as Jupyter or RStudio, because I also write a lot of little bash/shell scripts or just one-liners embedded in markdown (my projects notebooks). Also, the &lt;a href=&quot;https://github.com/adomingues/NGSpipe2go&quot;&gt;pipeline&lt;/a&gt; I am using is based on groovy. Sometimes I write code in all 4 languages in a single day, and thus it is easy to see why I prefer a single development environment instead of having to memorize different shortcuts/layouts. Personally it makes my life easier. Also, I love the multi-line editing features of sublime text and the ability to search within projects, etc.&lt;/p&gt;

&lt;p&gt;Recently I upgrade to version 3, and re-installed my most used packages. I will leave the list here for future reference, and in case someone else is interested.&lt;/p&gt;

&lt;h2 id=&quot;packages&quot;&gt;Packages&lt;/h2&gt;

&lt;p&gt;Installed packages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/installation&quot;&gt;package control&lt;/a&gt;, to manage all packages&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mangecoeur/AcademicMarkdown&quot;&gt;AcademicMarkdown&lt;/a&gt;, neat highlighting of markdown syntax.&lt;/li&gt;
  &lt;li&gt;MarkdownEditing&lt;/li&gt;
  &lt;li&gt;All &lt;a href=&quot;https://github.com/alienhard/SublimeAllAutocomplete&quot;&gt;Autocomplete&lt;/a&gt; auto complete using matches from any of the open files.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/facelessuser/BracketHighlighter&quot;&gt;BracketHighlighter&lt;/a&gt; extends the default bracket highlighting from sublime text.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/andrewheiss/SublimeKnitr&quot;&gt;SublimeKnitr&lt;/a&gt;, requires R-Box, SendREPL and LaTeXing. knitr Markdown and LaTeX support.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/packages/LaTeX-cwl&quot;&gt;LaTeX-cwl&lt;/a&gt;, LateX commands auto-complete&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sublimetext.com/docs/3/spell_checking.html&quot;&gt;Spell checking&lt;/a&gt;, because tipos :)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/revolunet/sublimetext-markdown-preview&quot;&gt;markdown-preview&lt;/a&gt;, build and preview markdown files in Sublime.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/packages/SideBarEnhancements&quot;&gt;SideBarEnhancements&lt;/a&gt;, copy, delete, rename and other file opearations from your side bar.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter&quot;&gt;SublimeLinter&lt;/a&gt;, verification of code quality for:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/jimhester/SublimeLinter-contrib-lintr&quot;&gt;lintr&lt;/a&gt;, R&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/SublimeLinter/SublimeLinter-pep8&quot;&gt;pep8&lt;/a&gt;, Python&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/SublimeLinter/SublimeLinter-shellcheck&quot;&gt;shellcheck&lt;/a&gt;, Shell&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/packages/R_comments&quot;&gt;R_comments&lt;/a&gt;, easy insertion of nicely formatted R comments.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jvcasillas.com/code/projects/R-snippets&quot;&gt;R-snippets&lt;/a&gt;, collection of R snippets.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bitbucket.org/StephaneBunel/pythonpep8autoformat&quot;&gt;pythonpep8autoformat&lt;/a&gt;, formats old code with pep8 rules.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/petervaro/python&quot;&gt;python3&lt;/a&gt;, syntax highlighting.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/carlcalderon/sublime-color-schemes&quot;&gt;carlcalderon sublime color schemes&lt;/a&gt;, I prefer not so dark schemes, and use the Tyrann Kim or the Tyrann Alex.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the above the single most important one is &lt;code&gt;SendREPL&lt;/code&gt; which allows me to send commands straight from the editor to the terminal (with &lt;code&gt;tmux&lt;/code&gt;) with a keystroke &lt;code&gt;ctrl+[enter]&lt;/code&gt;. It does not matter if in &lt;code&gt;tmux&lt;/code&gt; there is an R terminal, python console, or pure ol’ bash. This flexibility is precious.&lt;/p&gt;

&lt;h2 id=&quot;extras&quot;&gt;Extras&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;AcademicMarkdown&lt;/code&gt; code blocks do not highlight code in blocks labelled “bash”, but only has “shell”, or “sh”. This is in an &lt;a href=&quot;https://github.com/mangecoeur/AcademicMarkdown/issues/12&quot;&gt;issue&lt;/a&gt; when converting to html via pandoc. To solve this, I simple followed &lt;a href=&quot;http://www.sublimetext.com/docs/3/packages.html&quot;&gt;these instructions&lt;/a&gt;, and modified locally the file &lt;a href=&quot;https://github.com/mangecoeur/AcademicMarkdown/blob/3e7ff4bf7498bbbfe49650cfcfe265a7bfe06e66/AcademicMarkdown.tmLanguage&quot;&gt;AcademicMarkdown.tmLanguage&lt;/a&gt; from:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;		&amp;lt;key&amp;gt;fenced-shell&amp;lt;/key&amp;gt;
		&amp;lt;dict&amp;gt;
		    &amp;lt;key&amp;gt;begin&amp;lt;/key&amp;gt;
		    &amp;lt;string&amp;gt;^(\s*[`~]{3,})(sh|shell)\s*$&amp;lt;/string&amp;gt;
		    &amp;lt;key&amp;gt;end&amp;lt;/key&amp;gt;
		    &amp;lt;string&amp;gt;^(\1)\n&amp;lt;/string&amp;gt;
		    &amp;lt;key&amp;gt;name&amp;lt;/key&amp;gt;
		    &amp;lt;string&amp;gt;markup.raw.block.markdown markup.raw.block.fenced.markdown&amp;lt;/string&amp;gt;
		    &amp;lt;key&amp;gt;patterns&amp;lt;/key&amp;gt;
		    &amp;lt;array&amp;gt;
		        &amp;lt;dict&amp;gt;
		            &amp;lt;key&amp;gt;include&amp;lt;/key&amp;gt;
		            &amp;lt;string&amp;gt;source.shell&amp;lt;/string&amp;gt;
		        &amp;lt;/dict&amp;gt;
		    &amp;lt;/array&amp;gt;
		&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;		&amp;lt;key&amp;gt;fenced-shell&amp;lt;/key&amp;gt;
		&amp;lt;dict&amp;gt;
		    &amp;lt;key&amp;gt;begin&amp;lt;/key&amp;gt;
		    &amp;lt;string&amp;gt;^(\s*[`~]{3,})(sh|shell|bash)\s*$&amp;lt;/string&amp;gt;
		    &amp;lt;key&amp;gt;end&amp;lt;/key&amp;gt;
		    &amp;lt;string&amp;gt;^(\1)\n&amp;lt;/string&amp;gt;
		    &amp;lt;key&amp;gt;name&amp;lt;/key&amp;gt;
		    &amp;lt;string&amp;gt;markup.raw.block.markdown markup.raw.block.fenced.markdown&amp;lt;/string&amp;gt;
		    &amp;lt;key&amp;gt;patterns&amp;lt;/key&amp;gt;
		    &amp;lt;array&amp;gt;
		        &amp;lt;dict&amp;gt;
		            &amp;lt;key&amp;gt;include&amp;lt;/key&amp;gt;
		            &amp;lt;string&amp;gt;source.shell&amp;lt;/string&amp;gt;
		        &amp;lt;/dict&amp;gt;
		    &amp;lt;/array&amp;gt;
		&amp;lt;/dict&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the inclusion of “bash” in the 4th line, and it now highlights fenced code labeled as “bash”. I am very proud of myself. It was fixed in the repo and a &lt;a href=&quot;https://github.com/mangecoeur/AcademicMarkdown/pull/19&quot;&gt;merge request&lt;/a&gt; sent in GitHub.&lt;/p&gt;

&lt;p&gt;I was also having a hard-time getting the “comment code” shortcut to work. This is a know bug that should have been solved in my version (Build 3114) bit it isn’t. Adding this to the use keybindings file &lt;a href=&quot;http://stackoverflow.com/questions/17742781/keyboard-shortcut-to-comment-lines-in-sublime-text-3&quot;&gt;solved&lt;/a&gt; the issue:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{ &quot;keys&quot;: [&quot;ctrl+7&quot;], &quot;command&quot;: &quot;toggle_comment&quot;, &quot;args&quot;: { &quot;block&quot;: false } },
{ &quot;keys&quot;: [&quot;ctrl+shift+7&quot;], &quot;command&quot;: &quot;toggle_comment&quot;, &quot;args&quot;: { &quot;block&quot;: true } }
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 01 Aug 2016 11:15:02 +0200</pubDate>
        <link>http://adomingues.github.io/2016/08/01/sublime-text-setup/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2016/08/01/sublime-text-setup/</guid>
        
        <category>SublimeText</category>
        
        <category>Code</category>
        
        <category>GitHub</category>
        
        
      </item>
    
      <item>
        <title>Custom chromosome sizes for pybedtools</title>
        <description>&lt;p&gt;I use &lt;code&gt;pybetools&lt;/code&gt; a lot in my little script. One issue that I have encountered recentely was when using those scripts with a custom genome, in this case mapping to the transcriptome. One of my scripts calculates using &lt;code&gt;genome_coverage(bg=True, genome=genome)&lt;/code&gt; and the argument &lt;code&gt;genome&lt;/code&gt;, is an input from the command line.&lt;/p&gt;

&lt;p&gt;And what is this &lt;code&gt;genome&lt;/code&gt; I speak of? It is a table that informs &lt;code&gt;pybedtools&lt;/code&gt; of the sizes of the chromosomes in the reference. Useful among other things to calculate coverage and to avoid extending genomic regions more that the size of the reference chromosome with &lt;code&gt;slop&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;what-is-the-problem&quot;&gt;What is the problem?&lt;/h1&gt;

&lt;p&gt;Having to create custom tables for each genome might be annoying. Also, I would like to reduce the number of arguments in my scripts. So while this is not an issue for most application, at some point one will run into annoyances that are part and parcel of custom genomes/annotations/applications.&lt;/p&gt;

&lt;h1 id=&quot;the-solution&quot;&gt;The solution&lt;/h1&gt;

&lt;p&gt;There is this thing called &lt;code&gt;samtools idxstats&lt;/code&gt; which outputs the chromosome lengths (and read counts per chromosome) for bam files. It just happens that the main input of my scripts tend to be bam files, and that &lt;code&gt;idxstats&lt;/code&gt; has been implemented in &lt;code&gt;pysam&lt;/code&gt;. This means that with a simple function the chromosome lengths could be derived from the bam without extra hassle (said he before the bugs crept in).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def get_chrom_lengths(path_to_bam):
   &#39;&#39;&#39;
   Uses pysam to retrieve chromosome sizes form bam.
   Useful helper to use with some pybedtools functions (e.g. coverage), when a bam was mapped with custom genome not available in UCSC.
   Input: path to bam file (should be indexed)
   Output: dictionary.
   Example ouput:
   {&#39;chr4&#39;: (0, 1351857), &#39;chr3L&#39;: (0, 24543557), &#39;chr2L&#39;: (0, 23011544), &#39;*&#39;: (0, 0), &#39;chrX&#39;: (0, 22422827), &#39;chr2R&#39;: (0, 21146708), &#39;chr3R&#39;: (0, 27905053)}
   &#39;&#39;&#39;
   import pysam
   idx = pysam.idxstats(path_to_bam).splitlines()
   chromsizes = {}
   for element in idx:
      stats = element.split(&quot;\t&quot;)
      chromsizes[stats[0]] = (0, int(stats[1]))
   return chromsizes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a little test will show that the chromosome sizes obtained with this function are equivalent to those retrieved by &lt;code&gt;pybedtools&lt;/code&gt; from UCSC (or their database):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pybedtools
bam = pybedtools.example_filename(&#39;x.bam&#39;)
pysam.index(bam) # with indexing it will not work

#my function
chromsizes = get_chrom_lengths(bam)

# pybedtools in-built function
dm3 = pybedtools.genome_registry.dm3.euchromatic
print dm3

# test
a = pybedtools.example_bedtool(&#39;x.bed&#39;)
cov_dm3 = a.genome_coverage(bg=True, genome=&#39;dm3&#39;)
cov_chrsizes = a.genome_coverage(bg=True, genome=chromsizes)

print cov_dm3.head()
print cov_chrsizes.head()

cov_dm3 == cov_chrsizes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: it is working with pysam 0.9.0 but might untested for other versions where the parsing might be &lt;a href=&quot;https://github.com/pysam-developers/pysam/issues/245&quot;&gt;different&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Apr 2016 16:15:02 +0200</pubDate>
        <link>http://adomingues.github.io/2016/04/22/Custom-genome-sizes/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2016/04/22/Custom-genome-sizes/</guid>
        
        <category>pybetools</category>
        
        <category>pysam</category>
        
        <category>python</category>
        
        <category>genome</category>
        
        
      </item>
    
      <item>
        <title>Repeat mapping</title>
        <description>&lt;p&gt;Most of the projects I am involved with deal with mapping reads to repeat regions of the genome. Specifically transposons. While not all genomic repeats have &lt;strong&gt;exactly&lt;/strong&gt; the same sequence, it is nonetheless challenging to accurately map as many reads as possible - more reads mapped -&amp;gt; more information (for the same €€).&lt;/p&gt;

&lt;h1 id=&quot;what-is-the-problem&quot;&gt;What is the problem?&lt;/h1&gt;

&lt;p&gt;The issue is what to with reads whose mapping location is uncertain, or rather that map to more than one genomic position. What to do next? We can overall find in the literature two consensual ways to deal with this problem (at the level of mapping):
- retain only reads that map one (unique mappers) gives us confidence about the read position in exchange for loss of information;
- randomly assign to a single location a read that map multiple times (multi-mappers), ensuring increased read numbers at the expense of uncertainty about the origin of the reads.&lt;/p&gt;

&lt;p&gt;There also post-mapping strategies to quantify expression of repeat regions. For instance one can allow random assignment of multimapping reads and simply quantify classes of Repeats. The assumption here is that if a read maps to multiple times with the same confidence it will probably be to different copies of the &lt;em&gt;same&lt;/em&gt; element. Exact genomic location is not important, only the element. ERANGE on the other hand, uses uniquely mapping reads to calculate which repeats (genes) are more likely to be expressed, and by how much, and then assigns the multimapping reads to genes based on the estimate.&lt;/p&gt;

&lt;p&gt;Regardless, there will genes with so many copies with almost identical sequences in the genome, that it will be virtually impossible to map reads (or quantify expression) to any of those copies. This is the &lt;em&gt;black hole&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;beware-of-dragons&quot;&gt;Beware of Dragons&lt;/h1&gt;

&lt;p&gt;The above introduction serves to say that when it comes to the mapping in repeat sequences/regions, there is no right way of doing it, and compromises will have to be taken. These choices should always be present when analyzing and interpreting the downstream results.&lt;/p&gt;

&lt;p&gt;So, there is no &lt;em&gt;right&lt;/em&gt; solution for this problem, but could there be a (or many) wrong way(s) of doing it?&lt;/p&gt;

&lt;p&gt;There are certainly two papers that I am aware of that came under scrutiny for the strategy used when dealing with reads mapping to repetitive regions. The most recent one, &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/pubmed/24998597&quot;&gt;Samans et al&lt;/a&gt;, was dissected &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/pubmed/27046835&quot;&gt;here&lt;/a&gt;. I will not review in detail the arguments, but the main contention is that by using the bowtie parameter &lt;code&gt;-a&lt;/code&gt; Saman et al. is counting each multimapping read multiple times. Basically if a read maps to 2 positions in the genome, it will be assigned to both positions.&lt;/p&gt;

&lt;p&gt;1 becomes 2.&lt;/p&gt;

&lt;p&gt;2 can be hundreds.&lt;/p&gt;

&lt;p&gt;As we can expect, Royo et al. when re-analysing the data shows that this affects disproportionately reads mapping to repeat regions, with a large increase in mappings to these regions. This is significant because Saman et al. found a strong enrichment of nucleosomes at repetitive regions. Two senior authors of the Samans et al study replied and &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/pubmed/27046829&quot;&gt;stood by their conclusions&lt;/a&gt; arguing that these dark regions of the genome (more than half of the mammalian genome) must be considered in the data analysis and not simply throw away the data. This is very true and I agree with their sentiment, but facing the choice between ignoring reads for which the location I am unsure of, or ignoring them, I will stray on the side of caution. I will definitely avoid multiple assignment (double counting) of reads.&lt;/p&gt;

&lt;p&gt;Previously, a paper by &lt;a href=&quot;www.ncbi.nlm.nih.gov/pubmed/23434410&quot;&gt;Huang et al&lt;/a&gt; found enrichment of Piwi (an Argonaut protein involved in transposon repression) in transposon loci, using ChIP-seq. &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/pubmed/25805138&quot;&gt;Marinov et al&lt;/a&gt; re-analyzed the data, and in my opinion the most important control - simply swapping input background with the Piwi IP for peak calling - showed similar enrichment at transposons. In a reply, &lt;a href=&quot;http://www.ncbi.nlm.nih.gov/pubmed/25805139&quot;&gt;Lin et al.&lt;/a&gt; upon re-analysis of their own data, agree that the genomic targets of Piwi are still unknown. Once again the results falter due (mostly) to the handling of multimapping reads. There are other issues, namely the non-standard peak-calling, which should be an eye opener to anyone interested in mapping to transposons/repeats.&lt;/p&gt;

&lt;p&gt;I did not dwell in the biological questions being address by Samans et al. or Huang et al., nor on the finer details. The goal is to bring some attention, and focus my mind in the issue of multimapping reads. I live in constant paranoia that a simple mistake (switching &lt;code&gt;-M&lt;/code&gt; for &lt;code&gt;-m&lt;/code&gt; in bowtie), or lack of understanding of the best practices will result in poor results. It can happen to anyone, so please go ahead and read the papers, specially the re-analyses and rebuttals. It is just a few pages each and it save many headaches in the future.&lt;/p&gt;

&lt;h1 id=&quot;is-there-a-way-to-kill-the-dragons&quot;&gt;Is there a way to kill the Dragons?&lt;/h1&gt;

&lt;p&gt;As you can probably notice, this multimapping reads issue is a lot on my mind. Sometime ago after lab discussions, and embryonic idea of how assign these reads started taking shape. Something like:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;map reads and keep multi-mappers.&lt;/li&gt;
  &lt;li&gt;use uniquely map reads to estimate local coverage&lt;/li&gt;
  &lt;li&gt;assign multi-mappers to regions based on the coverage. That is, if there are 100 non-redundant reads that map with equal confidence (as assigned by the mapper) to two locations in the genome, one with coverage=10 and the other with coverage=1, the 9/10 of the 100 reads would go to a position 1 and 1/10 to position 2.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that this is not the same as existing solution of &lt;strong&gt;counting&lt;/strong&gt; a read proportionally to the number of mapping positions. The output would be a sam/bam alignment file in which every single read would have a single genomic position. This alignment file could then be used for instance to call peaks.&lt;/p&gt;

&lt;p&gt;With my very näive solution also came the though: “someone smarter than me already though to something like this”. So I put this on my TODO when-there-is-time list, and kept an eye in the literature.&lt;/p&gt;

&lt;p&gt;Now, a group of smarter people than me did put this solution into a proper package, &lt;a href=&quot;http://dx.doi.org/10.1101/044099&quot;&gt;ShortStack&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Improved Placement of Multi-Mapping Small RNAs&lt;/strong&gt;
Nathan R. Johnson, Jonathan M. Yeoh, Ceyda Coruh, and Michael J. Axtell
Article Summary:
High-throughput sequencing of small RNAs (sRNA-seq) is a frequently used technique in the study of small RNAs. Alignment to a reference genome is a key step in processing sRNA-seq libraries, but suffers from enormous rates of multi-mapping reads. Current methods for sRNA- seq alignment either place these reads randomly or ignore them, both of which distort downstream analyses. Here, we describe a locality-based weighting approach to make better decisions of placement of multi-mapped sRNA-seq data, and test our implementation of this method. We find that our method gives superior performance in terms of placing multi-mapped sRNA-seq data. An implementation of our method is freely available within the ShortStack small RNA analysis program. Use of this method may dramatically improve genome-wide analyses of small RNAs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Isn’t great? They even put it up as preprint in biorxiv. This is quite crucial because in a typical small RNA-seq experiment we only get about 20-30% of unique mappers, and 50-60% of reads are multi-mappers. If the results of the paper hold true, about 70-30% of these multi-mappers would be “saved” by ShortStack. I still have to test it for ChIP-seq, but it looks promising.&lt;/p&gt;

&lt;p&gt;ShortStack is not the panacea for all the multimapping issues, and authors acknowledge that for some reads assigning a single genomic position, but it should increase the number of available reads for downstream analysis, post-mapping, without sacrificing accuracy.&lt;/p&gt;

&lt;p&gt;Good times ahead.&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Apr 2016 13:15:02 +0200</pubDate>
        <link>http://adomingues.github.io/2016/04/21/Repeat-mapping/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2016/04/21/Repeat-mapping/</guid>
        
        <category>Mapping</category>
        
        <category>Repeats</category>
        
        <category>Review</category>
        
        <category>small RNA-seq</category>
        
        
      </item>
    
      <item>
        <title>Kill all jobs with a name</title>
        <description>&lt;p&gt;I had some jobs waiting in queue with non-consecutive job id numbers, but all with the same job name. Mistakes were made and they needed killing. A solution would be to copy-paste all the relevant job IDs and go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;bkill 1001 1002 1030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But where is the fun in that? (Not mention that mistake could have been made and unintended jobs might have been canceled).&lt;/p&gt;

&lt;h1 id=&quot;solution&quot;&gt;Solution&lt;/h1&gt;

&lt;p&gt;How to kill all jobs in queue with a certain name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;j=`bjobs | grep bam2bw | awk &#39;{print $1}&#39;`
bkill $j
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;grep&lt;/code&gt; will capture the jobs with a particular name, also using patters if needed, and &lt;code&gt;awk&lt;/code&gt; will print the column with the job ids. &lt;code&gt;awk&lt;/code&gt; could have also been used to capture the relevant jobs, but I feel more comfortable using &lt;code&gt;grep&lt;/code&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Apr 2016 13:47:02 +0200</pubDate>
        <link>http://adomingues.github.io/2016/04/07/kill-bsub-jobs/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2016/04/07/kill-bsub-jobs/</guid>
        
        <category>queue</category>
        
        
      </item>
    
      <item>
        <title>Testing for over-representation of anything</title>
        <description>&lt;p&gt;Recently I wrote a post on how to test for &lt;a href=&quot;http://adomingues.github.io/2015/03/19/chromosome-over-representation-in-DGE/&quot;&gt;chromosome over-representation&lt;/a&gt; on a list of genes. The solution, which I thought it was clever at the time, can be simpled to be applied to test if overlap between two lists of genes is significant. Let’s use the pasilla data again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;# library(&quot;Biobase&quot;)
library(&quot;pasilla&quot;)
library(&quot;Biobase&quot;)
library(&quot;DESeq&quot;)

data(&quot;pasillaGenes&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From that we can select two list of genes to test for overlap significance using my homemade approach (fisher exact test, &lt;code&gt;fisher.test&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;geneset1 &amp;lt;- sample(rownames(counts(pasillaGenes)), 2500)
geneset2 &amp;lt;- sample(rownames(counts(pasillaGenes)), 3500)

universe &amp;lt;- length(
   unique(rownames(counts(pasillaGenes)))
   )

common &amp;lt;- length(
   intersect(
      unique(geneset1),
      unique(geneset2)
      )
   )


mat &amp;lt;- matrix(
   c(
      universe - length(union(geneset1, geneset2)),
      length(setdiff(geneset1, geneset2)),
      length(setdiff(geneset2, geneset1)),
      length(intersect(geneset1, geneset2))
      ),
   nrow=2
   )

fr &amp;lt;- fisher.test(mat, alternative=&quot;greater&quot;)
fr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this a random set of genes, it is not surprising that there is no overlap. This works fairly well and it could even be wrapped in a nice function. Yep, someone else has done &lt;a href=&quot;http://rpackages.ianhowson.com/bioc/GeneOverlap/man/GeneOverlap.html&quot;&gt;it&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;geneoverlap&quot;&gt;GeneOverlap&lt;/h1&gt;

&lt;p&gt;Amongst other things, including visualization of overlaps, this package has a  great function, &lt;code&gt;testGeneOverlap&lt;/code&gt;, which uses an object created with &lt;code&gt;newGeneOverlap&lt;/code&gt;, that does exactly the above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(GeneOverlap)
overl &amp;lt;- newGeneOverlap(
   unique(geneset1),
   unique(geneset2),
   genome.size=universe)

overl &amp;lt;- testGeneOverlap(overl)
print(overl)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Detailed information about this GeneOverlap object:
## listA size=2500, e.g. FBgn0031233 FBgn0035504 FBgn0050468
## listB size=3500, e.g. FBgn0035004 FBgn0085756 FBgn0036820
## Intersection size=583, e.g. FBgn0015805 FBgn0038159 FBgn0052354
## Union size=5417, e.g. FBgn0031233 FBgn0035504 FBgn0050468
## Genome size=14470
## # Contingency Table:
##      notA  inA
## notB 9053 1917
## inB  2917  583
## Overlapping p-value=0.87
## Odds ratio=0.9
## Overlap tested using Fisher&#39;s exact test (alternative=greater)
## Jaccard Index=0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the results is the same. However, &lt;code&gt;GeneOverlap&lt;/code&gt; also outputs the results of a few more tests that can be quite useful:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Fisher’s exact test also gives an odds ratio which represents the strength of association. If an odds ratio is equal to or less than 1, there is no association between the two lists. If the odds ratio is much larger than 1, then the association is strong. The class also calculates the Jaccard index which measures the similarity between two lists. The Jaccard index varies between 0 and 1, with 0 meaning there is no similarity between the two and 1 meaning the two are identical.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The explanations are also quite nice for beginners. Great Bioconductor package.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2016 19:02:00 +0100</pubDate>
        <link>http://adomingues.github.io/2016/02/14/test-gene-overlap/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2016/02/14/test-gene-overlap/</guid>
        
        <category>R</category>
        
        <category>Bioconductor</category>
        
        <category>Fisher</category>
        
        
      </item>
    
      <item>
        <title>Merge fastq sample from different lanes and rename them</title>
        <description>&lt;p&gt;This is something I need to do often and a collegue asked me how to do it herself. So the best way to share is to post it in the blog.&lt;/p&gt;

&lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;

&lt;p&gt;Quite often samples are sequenced in multiple lanes, or for whatever reason are split in multiple file, which we receive. Before processing, I like to join the fastq files and rename the at that point - afterwards everything  will have plot names which are mostly presentation/publication ready, so one last thing to change manually.&lt;/p&gt;

&lt;h1 id=&quot;st-step-merge&quot;&gt;1st step: merge&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PROJECT=&#39;my_project&#39;

# create project folder
mkdir -p ${PROJECT}/data/reads/03_December_2015
cd ${PROJECT}/data/reads/03_December_2015

# copy original reads - these will always be kept!
rsync -r -t -x -v --progress -u -l -z -s /fsimb/exchange/imb-genomicscf/AG_Ketting/imb_ketting_2015_22/ ./

# merge the reads in parallel taking advantage of the cluster
mkdir -p logs
for f in $(find ./ -type d -name &quot;*imb*&quot;);
do
    echo $f
    bsub -q short -n 1 -app Reserve3G -o logs/output.txt -J logs/mergeFastQ_&quot;$f&quot; -e logs/mergeFastQ_&quot;$f&quot;.err.log mergeFastQ.sh $f &quot;single&quot;
done

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will call &lt;code&gt;mergeFastQ.sh&lt;/code&gt; that changes to each sample directory and merges the files therein (save it in a folder that is on your &lt;code&gt;$PATH&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/usr/bin/env bash

# mergeFastQC.sh
# António Domingues
# 22.01.2015

cd $1
# outname=`echo $1 | sed -r &#39;s/_[a-Z]{6}_.*(_R[1-2]).*$/\1/&#39;`
outname=${PWD##*/}
echo $outname
# read1=`find -name &quot;*R1*.fastq.gz&quot;`
# read2=`find -name &quot;*R2*.fastq.gz&quot;`


if [ &quot;$2&quot; = &quot;paired&quot; ]; then
   echo &quot;Paired&quot;

   cat *_R1_*.fastq.gz &amp;gt; &quot;$outname&quot;_R1.fastq.gz

   cat *_R2_*.fastq.gz &amp;gt; &quot;$outname&quot;_R2.fastq.gz

elif [ &quot;$2&quot; = &quot;single&quot; ]; then
   echo &quot;Single&quot;

   cat *_R1_*.fastq.gz &amp;gt; &quot;$outname&quot;.fastq.gz

fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nd-step-rename&quot;&gt;2nd step: rename&lt;/h1&gt;

&lt;p&gt;Once the merge is confirmed, merged files were renamed and moved to a merge folder. Original files were compressed in a folder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;
mkdir -p pooled

for f in $(find ./ -type f -name &quot;Sample*.fastq.gz&quot;);
do
    n=&quot;pooled/&quot;$(echo `basename $f` | sed -e &#39;s/Sample_imb_ketting_2015_22_[0-9]*_//&#39;)
    mv $f $n
done

# compress the original reads in tar and cleans up
tar cf Sample_imb_ketting_2015_20.tar $(find ./ -type d -name &quot;*imb*&quot;)
rm -rf $(find ./ -type d -name &quot;*imb*&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;rd-step-processing&quot;&gt;3rd step: processing&lt;/h1&gt;

&lt;p&gt;Once we have this we start the removal of poor quality reads, fastQC, mapping, etc. For his I take advantage of the Institutes’s pipelines, &lt;a href=&quot;https://github.com/imbforge/NGSpipe2go&quot;&gt;NGSpipe2go&lt;/a&gt;, to which I added a small RNA-seq pipeline. You can download the whole thing &lt;a href=&quot;https://github.com/adomingues/NGSpipe2go&quot;&gt;here&lt;/a&gt; to your &lt;code&gt;${PROJECT}&lt;/code&gt; folder and uncompress the zip file. Then to run you will only need one command: &lt;code&gt;bpipe run smallrnaseq_v0.1.txt data/reads/03_December_2015/*.fastq.gz&lt;/code&gt;. All the required scripts and files should be accessible.&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Dec 2015 00:00:00 +0100</pubDate>
        <link>http://adomingues.github.io/2015/12/03/renaming-and-merging-fastq/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2015/12/03/renaming-and-merging-fastq/</guid>
        
        <category>bash</category>
        
        <category>fastq</category>
        
        
      </item>
    
      <item>
        <title>Finding the closest element to a number in a vector</title>
        <description>&lt;p&gt;A colleague came to my office the other day with an interesting question:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Is there a way in R to find the closest number to X in a list?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I knowing full well the power the power of R, I naturally said that surely there is such a function, but I have never used it. So I set out to find it because I am curious. It turns out there is not an of the shelf &lt;code&gt;closest&lt;/code&gt; function. There are however a few solution out there which I have collected and are bellow. To top it off there is a comparison of how fast each solution is.&lt;/p&gt;

&lt;h1 id=&quot;solution-1&quot;&gt;solution 1&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2008-July/167226.html&quot;&gt;Source&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x=c(1:10^6)
your.number=90000.43
which(abs(x-your.number)==min(abs(x-your.number)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 90000
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;solution-2&quot;&gt;solution 2&lt;/h1&gt;
&lt;p&gt;Same source as before.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;which.min(abs(x-your.number))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] 90000
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;solution-3&quot;&gt;solution 3&lt;/h1&gt;
&lt;p&gt;From &lt;a href=&quot;http://stackoverflow.com/questions/20133344/find-closest-value-in-a-vector-with-binary-search&quot;&gt;here&lt;/a&gt;. It requires &lt;code&gt;data.table&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;install.packages(&quot;data.table&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Installing package into &#39;/home/adomingu/R/x86_64-pc-linux-gnu-library/3.2&#39;
## (as &#39;lib&#39; is unspecified)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Error in contrib.url(repos, type): trying to use CRAN without setting a mirror
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(data.table)
dt = data.table(x, val = x) # you&#39;ll see why val is needed in a sec
setattr(dt, &quot;sorted&quot;, &quot;x&quot;)  # let data.table know that w is sorted
setkey(dt, x) # sorts the data

# binary search and &quot;roll&quot; to the nearest neighbour
# In the final expression the val column will have the you&#39;re looking for.
dt[J(your.number), roll = &quot;nearest&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##        x   val
## 1: 90000 90000
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;speed-comparison&quot;&gt;Speed comparison&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;## time:
# solution1
system.time(which(abs(x-your.number)==min(abs(x-your.number))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.024   0.020   0.043
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;# solution2
system.time(which.min(abs(x-your.number)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.008   0.004   0.012
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;# solution3
system.time(dt[J(your.number), roll = &quot;nearest&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.000   0.000   0.001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To my surprise the base R functions perform pretty well, though in really large datasets &lt;code&gt;data.table&lt;/code&gt; is worth a punt.&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Sep 2015 00:00:00 +0200</pubDate>
        <link>http://adomingues.github.io/2015/09/24/finding-closest-element-to-a-number-in-a-list/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2015/09/24/finding-closest-element-to-a-number-in-a-list/</guid>
        
        <category>R</category>
        
        
      </item>
    
      <item>
        <title>Table of results embed in a PDF</title>
        <description>&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: This is a rant.&lt;/p&gt;

&lt;p&gt;I had to run a quick analysis on someone else’s results. You probably know the drill: there is a paper which reported a list of differential expressed genes for a condition that is relevant to your project. One thinks:
&amp;gt; Great! Assuming the analysis is correct, I can poke around their data and compare/extract results that are relevant to my project.&lt;/p&gt;

&lt;p&gt;That is where the fun ends. In this particular paper, they where kind enough to report the processed tables of results in a single PDF.&lt;/p&gt;

&lt;p&gt;Seriously? All 4 tables of results were embedded in a single PDF. The lists of up and down-regulated genes spanned several pages. Is it that hard to have supplement text files with the relevant tables? Or if that is not convenient for data presentation (yes, there were highlighted row in the tables), at the very least make the original excel tables available. Unless all the calculations were painstakingly done by hand and noted down in Word, it seems that it was more difficult to move the table from Excel -&amp;gt; Word -&amp;gt; PDF than just published the excel files in the first place.&lt;/p&gt;

&lt;h2 id=&quot;extraction-of-table-from-pdf-to-r-friendly-format&quot;&gt;Extraction of table from PDF to R-friendly format&lt;/h2&gt;
&lt;p&gt;To extract the list of differentially expressed genes embedded in the supp. data pdf, I used okular following this &lt;a href=&quot;http://stackoverflow.com/a/11437638/1274242&quot;&gt;tip&lt;/a&gt;. However, when copying directly to Oo Calc I stumbled upon some encoding problems, so in the end table was copied to a text editor (the column that was relevant to me). It is not ideal but solved the problem. It took me an hour all in all.&lt;/p&gt;

&lt;p&gt;Of course, I could have download the raw reads, QC, map, count, re-do the analysis, compare to the published results to make sure all is kosher, but having the table of DEG saves a lot time that we can focus on extracting biologically relevant insights. That is what science should be about and sharing knowledge, in the format of papers, should be a help in this endeavor and not an hindrance.&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Apr 2015 15:52:02 +0200</pubDate>
        <link>http://adomingues.github.io/2015/04/16/rant-about-results-tables/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2015/04/16/rant-about-results-tables/</guid>
        
        <category>Jekyll</category>
        
        
      </item>
    
      <item>
        <title>Painless installation of R packages from source</title>
        <description>&lt;p&gt;I was minding my own business trying to add labels to a line plot in &lt;code&gt;ggplot2&lt;/code&gt;. Then I saw that the package &lt;a href=&quot;http://directlabels.r-forge.r-project.org/&quot;&gt;directlabels&lt;/a&gt; would solve all my problems with one single line of code. I proceed to install it using &lt;code&gt;install.packages(&quot;directlabels&quot;, repo=&quot;http://r-forge.r-project.org&quot;)&lt;/code&gt;. Sadly:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;package &lt;code&gt;directlabels&lt;/code&gt; is not available (for R version 3.1.3)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Usually, I would download the source code, then use &lt;code&gt;install.packages()&lt;/code&gt; from source. But this still did not work due some dependency issues. Thankfully there is the package &lt;code&gt;devtools&lt;/code&gt; to help:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;library(devtools)
install_url(&amp;quot;http://cran.r-project.org/src/contrib/directlabels_2013.6.15.tar.gz&amp;quot;)
library(directlabels)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As simple as that. It also allows installation from github repos.&lt;/p&gt;

</description>
        <pubDate>Thu, 16 Apr 2015 11:32:22 +0200</pubDate>
        <link>http://adomingues.github.io/2015/04/16/install-r-packages-from-source/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2015/04/16/install-r-packages-from-source/</guid>
        
        <category>R</category>
        
        <category>devtools</category>
        
        
      </item>
    
      <item>
        <title>Testing for chromosome over-representation</title>
        <description>&lt;p&gt;Sometimes I am working on some data and notice certain biases, say differentially expressed genes appearing to originate more often from a chromosome. Or a factor binding more often to a class of transcripts. In these situations I tend to turn to Fisher’s exact test. Here I will put an example of what I do.&lt;/p&gt;

&lt;h2 id=&quot;get-some-data&quot;&gt;Get some data&lt;/h2&gt;

&lt;p&gt;For the sake of simplicity I will use data from the Pasilla&lt;a href=&quot;http://bioconductor.org/packages/release/data/experiment/html/pasilla.html&quot;&gt;1&lt;/a&gt; dataset and run differential gene expression analysis with DESeq2&lt;a href=&quot;http://www.bioconductor.org/packages/release/bioc/html/DESeq2.html&quot;&gt;2&lt;/a&gt; following the vignette’s instructions. The &lt;code&gt;data.table&lt;/code&gt; package is used because I like it’s speed and syntax, specially for sub-setting. Since I am still learning all the ins and outs of it, I mix &lt;code&gt;data.frame&lt;/code&gt; code with it. Whatever works.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;library(&amp;quot;data.table&amp;quot;)
library(&amp;quot;pasilla&amp;quot;)
library(&amp;quot;Biobase&amp;quot;)
data(&amp;quot;pasillaGenes&amp;quot;)
library(&amp;quot;DESeq2&amp;quot;)
library(&amp;quot;biomaRt&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;While loading the &lt;code&gt;pasillaGenes&lt;/code&gt; R was throwing an error at me:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Warning: namespace ‘DESeq’ is not available and has been replaced&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It turns out that &lt;code&gt;DESeq&lt;/code&gt; needed to be installed to load the data. No idea why. So let’s get us some results:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;countData &amp;lt;- counts(pasillaGenes)
colData &amp;lt;- pData(pasillaGenes)[,c(&amp;quot;condition&amp;quot;,&amp;quot;type&amp;quot;)]
dds &amp;lt;- DESeqDataSetFromMatrix(
   countData = countData,
   colData = colData,
   design = ~ condition
   )
dds$condition &amp;lt;- relevel(dds$condition, &amp;quot;untreated&amp;quot;)
dds &amp;lt;- DESeq(dds)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;add-chromosome-information&quot;&gt;Add chromosome information&lt;/h2&gt;
&lt;p&gt;Now the fun starts. I created a &lt;code&gt;data.table&lt;/code&gt; with the results plus gene IDs, And will now added some extra information with biomaRt. I have only added chromosome and biotype, but the amount of information one can add is large. I usually also add gene symbol and description. Very useful to have a quick idea of the function of a particular gene. Adding the full gene location might be useful to later on subset data and easily create a bed file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;res &amp;lt;- as.data.frame(results(dds))
res$ensembl_gene_id &amp;lt;- rownames(results(dds))
res &amp;lt;- data.table(res)

ensembl = useMart(&amp;quot;ensembl&amp;quot;, dataset = &amp;quot;dmelanogaster_gene_ensembl&amp;quot;)
genemap &amp;lt;- getBM( attributes = c(&amp;quot;ensembl_gene_id&amp;quot;, &amp;quot;chromosome_name&amp;quot;, &amp;quot;gene_biotype&amp;quot;),
                  filters = &amp;quot;ensembl_gene_id&amp;quot;,
                  values = res$ensembl_gene_id,
                  mart = ensembl)
idx &amp;lt;- match( res$ensembl_gene_id, genemap$ensembl_gene_id )
res$chromosome &amp;lt;- genemap$chromosome_name[ idx ]
res$gene_biotype &amp;lt;- genemap$gene_biotype[ idx ]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now let’s have a look at down-regulated genes with &lt;code&gt;padj &amp;lt; 0.1&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;res[padj &amp;lt; 0.1 &amp;amp; log2FoldChange &amp;lt; 0]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;##        baseMean log2FoldChange     lfcSE      stat       pvalue
##   1:   85.00693     -0.7067901 0.2196386 -3.217969 1.291017e-03
##   2:  273.13010     -0.3878740 0.1360678 -2.850593 4.363776e-03
##   3: 1257.88508     -0.3896927 0.1321601 -2.948640 3.191754e-03
##   4:  280.32056     -0.4471012 0.1417352 -3.154483 1.607826e-03
##   5:  141.36961     -1.3409377 0.2076951 -6.456280 1.073079e-10
##  ---                                                           
## 404:  998.56567     -0.4335869 0.1357833 -3.193228 1.406921e-03
## 405:   16.42232     -0.6973109 0.2276632 -3.062906 2.191992e-03
## 406:  373.24468     -0.4988888 0.1441100 -3.461860 5.364557e-04
## 407: 2891.60114     -1.6134844 0.1706094 -9.457183 3.163516e-21
## 408:  973.77088     -0.8325356 0.1332384 -6.248464 4.145082e-10
##              padj ensembl_gene_id chromosome   gene_biotype
##   1: 2.007727e-02     FBgn0000079         2R protein_coding
##   2: 5.230444e-02     FBgn0000244         3R protein_coding
##   3: 4.105429e-02     FBgn0000256         2L protein_coding
##   4: 2.389391e-02     FBgn0000286         2L protein_coding
##   5: 1.045641e-08     FBgn0000406         2L protein_coding
##  ---                                                       
## 404: 2.158653e-02     FBgn0261545         2R protein_coding
## 405: 3.079189e-02     FBgn0261546         NA             NA
## 406: 9.950931e-03     FBgn0261547         3L protein_coding
## 407: 1.106943e-18     FBgn0261552         3R protein_coding
## 408: 3.710330e-08     FBgn0261560         2L protein_coding&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Most of these appear to be coding genes. Not a great surprise. But…  Oh! There are a lot of genes located in chromosome 2L. Is this a coincidence? Let us test it.&lt;/p&gt;

&lt;h2 id=&quot;test-for-over-representation&quot;&gt;Test for over-representation&lt;/h2&gt;

&lt;h3 id=&quot;chromosome-3l&quot;&gt;Chromosome 3L&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;chrom=&amp;quot;3L&amp;quot;
all &amp;lt;- res$ensembl_gene_id
hits &amp;lt;- res[padj &amp;lt; 0.1 &amp;amp; log2FoldChange &amp;lt; 0]$ensembl_gene_id
hits_in_chr &amp;lt;- length(res[chromosome == chrom &amp;amp; padj &amp;lt; 0.1 &amp;amp; log2FoldChange &amp;lt; 0]$ensembl_gene_id)
genes_in_chr &amp;lt;- length(res[chromosome == chrom]$ensembl_gene_id)
hits_total &amp;lt;- length(hits)
genes_total &amp;lt;- length(all)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Expected number of hits in chromosome 3L would be 71.8440912 and we have 61. Is this significant? I will use Fisher’s exact test, as applied &lt;a href=&quot;https://www.biostars.org/p/102946/&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://cgrlucb.wikispaces.com/Functional+Enrichment+Analysis&quot;&gt;here&lt;/a&gt; for very similar problems.&lt;/p&gt;

&lt;p&gt;Firstly I construct a table/matrix with the events and from that calculated Fisher’s Exact test, or the probability of having more genes in chromosome 3L than expected by chance. There are more details &lt;a href=&quot;http://cgrlucb.wikispaces.com/Functional+Enrichment+Analysis&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;mat &amp;lt;- matrix(
   c(
      hits_in_chr,
      genes_in_chr-hits_in_chr,
      hits_total-hits_in_chr,
      genes_total-hits_total-genes_in_chr+hits_in_chr
      ),
      nrow=2,
      ncol=2)
mat&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;##      [,1]  [,2]
## [1,]   61   347
## [2,] 2487 11575&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;fr &amp;lt;- fisher.test(mat, alternative=&amp;quot;greater&amp;quot;)
fr&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;## 
## 	Fisher&amp;#39;s Exact Test for Count Data
## 
## data:  mat
## p-value = 0.935
## alternative hypothesis: true odds ratio is greater than 1
## 95 percent confidence interval:
##  0.6400274       Inf
## sample estimates:
## odds ratio 
##  0.8181856&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So there is a p-value of 0.9349979 and we can reject the hypothesis that there is enrichment for or genes in 3L. My eyes were seeing patterns where this is none. Also, since I was testing only for over-representation, or enrichment, the option &lt;code&gt;alternative=&quot;greater&quot;&lt;/code&gt; was used in the test. Other options are available.&lt;/p&gt;

&lt;h3 id=&quot;for-all-chromosomes&quot;&gt;For all chromosomes&lt;/h3&gt;

&lt;p&gt;Is this this the case for any of the other chromosome? I will construct a function, and then loop over the chromosomes.&lt;/p&gt;

&lt;p&gt;The function &lt;code&gt;chrEnrichment&lt;/code&gt; is minimal and it only tests for down-regulated gens, but could be easily extended to add other arguments. It could also be used to test for biases in gene biotype.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;chrEnrichment &amp;lt;- function(chr, df){
   # Test for chromosome overpresentation in DESe2 results
   all &amp;lt;- df$ensembl_gene_id
   hits &amp;lt;- df[padj &amp;lt; 0.1 &amp;amp; log2FoldChange &amp;lt; 0]$ensembl_gene_id

   hits_in_chr &amp;lt;- length(res[chromosome == chr &amp;amp; padj &amp;lt; 0.1 &amp;amp; log2FoldChange &amp;lt; 0]$ensembl_gene_id)
   genes_in_chr &amp;lt;- length(res[chromosome == chr]$ensembl_gene_id)
   hits_total &amp;lt;- length(hits)
   genes_total &amp;lt;- length(all)

   mat &amp;lt;- matrix(
      c(
         hits_in_chr,
         genes_in_chr-hits_in_chr,
         hits_total-hits_in_chr,
         genes_total-hits_total-genes_in_chr+hits_in_chr
         ),
         nrow=2,
         ncol=2)
   fr &amp;lt;- fisher.test(mat, alternative=&amp;quot;greater&amp;quot;)
   df &amp;lt;- data.frame(
      chromosome = chromosome,
      observed = hits_in_chr,
      expected = round(hits_total * genes_in_chr / genes_total, 1),
      odds.ratio= fr$estimate[[&amp;quot;odds ratio&amp;quot;]],
      pvalue = fr$p.value
      )
   return(df)
}


chromosomes &amp;lt;- unique(na.omit(res[!like(chromosome,&amp;quot;Zv9&amp;quot;)])$chromosome)
l_res &amp;lt;- list()
for (chromosome in chromosomes){
   l_res[[chromosome]] &amp;lt;- chrEnrichment(chromosome, res)
}

table_fisher &amp;lt;- rbindlist(l_res)
table_fisher[,FDR:=p.adjust(pvalue, method=&amp;#39;bonferroni&amp;#39;),] # add FDR&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;##    chromosome observed expected odds.ratio     pvalue       FDR
## 1:         2R       91     78.1  1.2197190 0.05874683 0.4112278
## 2:         3L       61     71.8  0.8181856 0.93499788 1.0000000
## 3:         2L       86     70.2  1.2958104 0.02276513 0.1593559
## 4:         3R       95     90.2  1.0719388 0.29753414 1.0000000
## 5:          X       46     58.6  0.7523146 0.97261113 1.0000000
## 6:          4        0      2.3  0.0000000 1.00000000 1.0000000
## 7:       YHet        0      0.4  0.0000000 1.00000000 1.0000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;setkey(table_fisher, FDR) # will also sort by pvalue&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Since I am testing for all chromosomes, I have also calculated the adjusted p-value (bonferroni) to be on the safe side.&lt;/p&gt;

&lt;p&gt;And what does Fisher say?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;table_fisher&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;##    chromosome observed expected odds.ratio     pvalue       FDR
## 1:         2L       86     70.2  1.2958104 0.02276513 0.1593559
## 2:         2R       91     78.1  1.2197190 0.05874683 0.4112278
## 3:         3L       61     71.8  0.8181856 0.93499788 1.0000000
## 4:         3R       95     90.2  1.0719388 0.29753414 1.0000000
## 5:          X       46     58.6  0.7523146 0.97261113 1.0000000
## 6:          4        0      2.3  0.0000000 1.00000000 1.0000000
## 7:       YHet        0      0.4  0.0000000 1.00000000 1.0000000&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That we have a pretty much random distribution of down-regulated genes in the fly chromosomes.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;sessionInfo()&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;## R version 3.1.3 (2015-03-09)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 14.04.2 LTS
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=de_DE.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=de_DE.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=de_DE.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=de_DE.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] biomaRt_2.22.0            DESeq2_1.6.3             
##  [3] RcppArmadillo_0.4.650.1.1 Rcpp_0.11.5              
##  [5] GenomicRanges_1.18.4      GenomeInfoDb_1.2.4       
##  [7] IRanges_2.0.1             S4Vectors_0.4.0          
##  [9] Biobase_2.26.0            BiocGenerics_0.12.1      
## [11] pasilla_0.5.1             data.table_1.9.4         
## [13] knitr_1.9                
## 
## loaded via a namespace (and not attached):
##  [1] acepack_1.3-3.3      annotate_1.44.0      AnnotationDbi_1.28.1
##  [4] base64enc_0.1-2      BatchJobs_1.5        BBmisc_1.9          
##  [7] BiocParallel_1.0.3   bitops_1.0-6         brew_1.0-6          
## [10] checkmate_1.5.1      chron_2.3-45         cluster_2.0.1       
## [13] codetools_0.2-11     colorspace_1.2-6     DBI_0.3.1           
## [16] DESeq_1.18.0         digest_0.6.8         evaluate_0.5.5      
## [19] fail_1.2             foreach_1.4.2        foreign_0.8-63      
## [22] formatR_1.0          Formula_1.2-0        genefilter_1.48.1   
## [25] geneplotter_1.44.0   ggplot2_1.0.1        grid_3.1.3          
## [28] gtable_0.1.2         Hmisc_3.15-0         iterators_1.0.7     
## [31] lattice_0.20-30      latticeExtra_0.6-26  locfit_1.5-9.1      
## [34] MASS_7.3-39          munsell_0.4.2        nnet_7.3-9          
## [37] plyr_1.8.1           proto_0.3-10         RColorBrewer_1.1-2  
## [40] RCurl_1.95-4.5       reshape2_1.4.1       rpart_4.1-9         
## [43] RSQLite_1.0.0        scales_0.2.4         sendmailR_1.2-1     
## [46] splines_3.1.3        stringr_0.6.2        survival_2.38-1     
## [49] tools_3.1.3          XML_3.98-1.1         xtable_1.7-4        
## [52] XVector_0.6.0&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Thu, 19 Mar 2015 10:32:22 +0100</pubDate>
        <link>http://adomingues.github.io/2015/03/19/chromosome-over-representation-in-DGE/</link>
        <guid isPermaLink="true">http://adomingues.github.io/2015/03/19/chromosome-over-representation-in-DGE/</guid>
        
        <category>R</category>
        
        <category>Bioconductor</category>
        
        <category>Fisher</category>
        
        <category>biomaRt</category>
        
        
      </item>
    
  </channel>
</rss>
